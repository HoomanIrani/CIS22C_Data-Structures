/*
 Student: Houman Irani, Mahbod Mohebi
 Proffesor: Dr. Kamran Eftekhari
 CIS 22C
 De Anza College Summer 2019
 Description:    Final Project
 
 For this final programming project I implemented the Disjoint Sets, Stack, Queue, and Graph
 data structures to create a program that solves mazes that are either generated randomly or
 generated by hand following a certain format as specified in the assignment specifications.
 To solve the maze we populate our graph with data that indicates which of our rooms in the
 maze are neighbors to one another, and then use BFS and DFS algorithms to find the shortest
 path from the start room to finish room.
 
 */



#include "Graph.h"



Graph::Graph (int dim)
{
	if (dim < 2)
		dim = 5;

	arrDim = dim * dim;

	adjArr = new int*[arrDim];
	for (int i = 0; i < arrDim; i++)
	{
		adjArr[i] = new int[arrDim];
		for (int j = 0; j < arrDim; j++)
		{
			adjArr[i][j] = arrDim;
		}
	}
}



bool Graph::setNeighbors(int neighbor1, int neighbor2)
{
	bool ret = true;
	if ((neighbor1 >= 0 && neighbor1 < arrDim)
		&& (neighbor1 >= 0 && neighbor1 < arrDim))
	{
		adjArr[neighbor1][neighbor2] = 1;
		adjArr[neighbor2][neighbor1] = 1;
	}
	else
	{
		ret = false;
	}

	return ret;
}



bool Graph::isNeighbor(int neighbor1, int neighbor2)
{
	bool ret = true;
	if (neighbor1 < 0 || neighbor2 < 0 || neighbor1 >= arrDim || neighbor2 >= arrDim)
		ret = false;
	else if (adjArr[neighbor1][neighbor2] != 1)
		ret = false;

	return ret;
}



void Graph::printGraph()
{
	std::cout << "Contents of Graph" << std::endl;

	std::cout << "\t";
	for (int i = 0; i < arrDim; i++)
	{
		std::cout << "r" << i << " ";
	}
	std::cout << std::endl;

	for (int i = 0; i < arrDim; i++)
	{
		std::cout << "r" << i << "\t|";
		for (int j = 0; j < arrDim; j++)
		{
			if (adjArr[i][j] > 1)
				std::cout << "- ";
			else
				std::cout << "1 ";
		}

		std::cout << std::endl;
	}
}
